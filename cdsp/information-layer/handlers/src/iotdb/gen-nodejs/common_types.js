//
// Autogenerated by Thrift Compiler (0.14.1)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
"use strict";

var thrift = require('thrift');
var Thrift = thrift.Thrift;
var Q = thrift.Q;
var Int64 = require('node-int64');


var ttypes = module.exports = {};
ttypes.TConsensusGroupType = {
  'ConfigRegion' : 0,
  'DataRegion' : 1,
  'SchemaRegion' : 2
};
ttypes.TRegionMigrateFailedType = {
  'AddPeerFailed' : 0,
  'RemovePeerFailed' : 1,
  'RemoveConsensusGroupFailed' : 2,
  'DeleteRegionFailed' : 3,
  'CreateRegionFailed' : 4,
  'Disconnect' : 5
};
ttypes.TRegionMaintainTaskStatus = {
  'TASK_NOT_EXIST' : 0,
  'PROCESSING' : 1,
  'SUCCESS' : 2,
  'FAIL' : 3
};
ttypes.ThrottleType = {
  'REQUEST_NUMBER' : 0,
  'REQUEST_SIZE' : 1,
  'WRITE_NUMBER' : 2,
  'WRITE_SIZE' : 3,
  'READ_NUMBER' : 4,
  'READ_SIZE' : 5
};
ttypes.TServiceType = {
  'ConfigNodeInternalService' : 0,
  'DataNodeInternalService' : 1,
  'DataNodeMPPService' : 2,
  'DataNodeExternalService' : 3
};
ttypes.TAggregationType = {
  'COUNT' : 0,
  'AVG' : 1,
  'SUM' : 2,
  'FIRST_VALUE' : 3,
  'LAST_VALUE' : 4,
  'MAX_TIME' : 5,
  'MIN_TIME' : 6,
  'MAX_VALUE' : 7,
  'MIN_VALUE' : 8,
  'EXTREME' : 9,
  'COUNT_IF' : 10,
  'TIME_DURATION' : 11,
  'MODE' : 12,
  'COUNT_TIME' : 13,
  'STDDEV' : 14,
  'STDDEV_POP' : 15,
  'STDDEV_SAMP' : 16,
  'VARIANCE' : 17,
  'VAR_POP' : 18,
  'VAR_SAMP' : 19,
  'MAX_BY' : 20,
  'MIN_BY' : 21,
  'UDAF' : 22,
  'FIRST' : 23,
  'LAST' : 24,
  'FIRST_BY' : 25,
  'LAST_BY' : 26,
  'MIN' : 27,
  'MAX' : 28
};
ttypes.TrainingState = {
  'PENDING' : 0,
  'RUNNING' : 1,
  'FINISHED' : 2,
  'FAILED' : 3,
  'DROPPING' : 4
};
var TEndPoint = module.exports.TEndPoint = function(args) {
  this.ip = null;
  this.port = null;
  if (args) {
    if (args.ip !== undefined && args.ip !== null) {
      this.ip = args.ip;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ip is unset!');
    }
    if (args.port !== undefined && args.port !== null) {
      this.port = args.port;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field port is unset!');
    }
  }
};
TEndPoint.prototype = {};
TEndPoint.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.ip = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.port = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TEndPoint.prototype.write = function(output) {
  output.writeStructBegin('TEndPoint');
  if (this.ip !== null && this.ip !== undefined) {
    output.writeFieldBegin('ip', Thrift.Type.STRING, 1);
    output.writeString(this.ip);
    output.writeFieldEnd();
  }
  if (this.port !== null && this.port !== undefined) {
    output.writeFieldBegin('port', Thrift.Type.I32, 2);
    output.writeI32(this.port);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSStatus = module.exports.TSStatus = function(args) {
  this.code = null;
  this.message = null;
  this.subStatus = null;
  this.redirectNode = null;
  this.needRetry = null;
  if (args) {
    if (args.code !== undefined && args.code !== null) {
      this.code = args.code;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field code is unset!');
    }
    if (args.message !== undefined && args.message !== null) {
      this.message = args.message;
    }
    if (args.subStatus !== undefined && args.subStatus !== null) {
      this.subStatus = Thrift.copyList(args.subStatus, [null]);
    }
    if (args.redirectNode !== undefined && args.redirectNode !== null) {
      this.redirectNode = new ttypes.TEndPoint(args.redirectNode);
    }
    if (args.needRetry !== undefined && args.needRetry !== null) {
      this.needRetry = args.needRetry;
    }
  }
};
TSStatus.prototype = {};
TSStatus.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.code = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.message = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        this.subStatus = [];
        var _rtmp31 = input.readListBegin();
        var _size0 = _rtmp31.size || 0;
        for (var _i2 = 0; _i2 < _size0; ++_i2) {
          var elem3 = null;
          elem3 = new ttypes.TSStatus();
          elem3.read(input);
          this.subStatus.push(elem3);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.redirectNode = new ttypes.TEndPoint();
        this.redirectNode.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.BOOL) {
        this.needRetry = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSStatus.prototype.write = function(output) {
  output.writeStructBegin('TSStatus');
  if (this.code !== null && this.code !== undefined) {
    output.writeFieldBegin('code', Thrift.Type.I32, 1);
    output.writeI32(this.code);
    output.writeFieldEnd();
  }
  if (this.message !== null && this.message !== undefined) {
    output.writeFieldBegin('message', Thrift.Type.STRING, 2);
    output.writeString(this.message);
    output.writeFieldEnd();
  }
  if (this.subStatus !== null && this.subStatus !== undefined) {
    output.writeFieldBegin('subStatus', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.subStatus.length);
    for (var iter4 in this.subStatus) {
      if (this.subStatus.hasOwnProperty(iter4)) {
        iter4 = this.subStatus[iter4];
        iter4.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.redirectNode !== null && this.redirectNode !== undefined) {
    output.writeFieldBegin('redirectNode', Thrift.Type.STRUCT, 4);
    this.redirectNode.write(output);
    output.writeFieldEnd();
  }
  if (this.needRetry !== null && this.needRetry !== undefined) {
    output.writeFieldBegin('needRetry', Thrift.Type.BOOL, 5);
    output.writeBool(this.needRetry);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TConsensusGroupId = module.exports.TConsensusGroupId = function(args) {
  this.type = null;
  this.id = null;
  if (args) {
    if (args.type !== undefined && args.type !== null) {
      this.type = args.type;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field type is unset!');
    }
    if (args.id !== undefined && args.id !== null) {
      this.id = args.id;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field id is unset!');
    }
  }
};
TConsensusGroupId.prototype = {};
TConsensusGroupId.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.type = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.id = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TConsensusGroupId.prototype.write = function(output) {
  output.writeStructBegin('TConsensusGroupId');
  if (this.type !== null && this.type !== undefined) {
    output.writeFieldBegin('type', Thrift.Type.I32, 1);
    output.writeI32(this.type);
    output.writeFieldEnd();
  }
  if (this.id !== null && this.id !== undefined) {
    output.writeFieldBegin('id', Thrift.Type.I32, 2);
    output.writeI32(this.id);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSeriesPartitionSlot = module.exports.TSeriesPartitionSlot = function(args) {
  this.slotId = null;
  if (args) {
    if (args.slotId !== undefined && args.slotId !== null) {
      this.slotId = args.slotId;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field slotId is unset!');
    }
  }
};
TSeriesPartitionSlot.prototype = {};
TSeriesPartitionSlot.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.slotId = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSeriesPartitionSlot.prototype.write = function(output) {
  output.writeStructBegin('TSeriesPartitionSlot');
  if (this.slotId !== null && this.slotId !== undefined) {
    output.writeFieldBegin('slotId', Thrift.Type.I32, 1);
    output.writeI32(this.slotId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TTimePartitionSlot = module.exports.TTimePartitionSlot = function(args) {
  this.startTime = null;
  if (args) {
    if (args.startTime !== undefined && args.startTime !== null) {
      this.startTime = args.startTime;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field startTime is unset!');
    }
  }
};
TTimePartitionSlot.prototype = {};
TTimePartitionSlot.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.startTime = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TTimePartitionSlot.prototype.write = function(output) {
  output.writeStructBegin('TTimePartitionSlot');
  if (this.startTime !== null && this.startTime !== undefined) {
    output.writeFieldBegin('startTime', Thrift.Type.I64, 1);
    output.writeI64(this.startTime);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TRegionReplicaSet = module.exports.TRegionReplicaSet = function(args) {
  this.regionId = null;
  this.dataNodeLocations = null;
  if (args) {
    if (args.regionId !== undefined && args.regionId !== null) {
      this.regionId = new ttypes.TConsensusGroupId(args.regionId);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field regionId is unset!');
    }
    if (args.dataNodeLocations !== undefined && args.dataNodeLocations !== null) {
      this.dataNodeLocations = Thrift.copyList(args.dataNodeLocations, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field dataNodeLocations is unset!');
    }
  }
};
TRegionReplicaSet.prototype = {};
TRegionReplicaSet.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.regionId = new ttypes.TConsensusGroupId();
        this.regionId.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.dataNodeLocations = [];
        var _rtmp36 = input.readListBegin();
        var _size5 = _rtmp36.size || 0;
        for (var _i7 = 0; _i7 < _size5; ++_i7) {
          var elem8 = null;
          elem8 = new ttypes.TDataNodeLocation();
          elem8.read(input);
          this.dataNodeLocations.push(elem8);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TRegionReplicaSet.prototype.write = function(output) {
  output.writeStructBegin('TRegionReplicaSet');
  if (this.regionId !== null && this.regionId !== undefined) {
    output.writeFieldBegin('regionId', Thrift.Type.STRUCT, 1);
    this.regionId.write(output);
    output.writeFieldEnd();
  }
  if (this.dataNodeLocations !== null && this.dataNodeLocations !== undefined) {
    output.writeFieldBegin('dataNodeLocations', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.dataNodeLocations.length);
    for (var iter9 in this.dataNodeLocations) {
      if (this.dataNodeLocations.hasOwnProperty(iter9)) {
        iter9 = this.dataNodeLocations[iter9];
        iter9.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TNodeResource = module.exports.TNodeResource = function(args) {
  this.cpuCoreNum = null;
  this.maxMemory = null;
  if (args) {
    if (args.cpuCoreNum !== undefined && args.cpuCoreNum !== null) {
      this.cpuCoreNum = args.cpuCoreNum;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field cpuCoreNum is unset!');
    }
    if (args.maxMemory !== undefined && args.maxMemory !== null) {
      this.maxMemory = args.maxMemory;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field maxMemory is unset!');
    }
  }
};
TNodeResource.prototype = {};
TNodeResource.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.cpuCoreNum = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.maxMemory = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TNodeResource.prototype.write = function(output) {
  output.writeStructBegin('TNodeResource');
  if (this.cpuCoreNum !== null && this.cpuCoreNum !== undefined) {
    output.writeFieldBegin('cpuCoreNum', Thrift.Type.I32, 1);
    output.writeI32(this.cpuCoreNum);
    output.writeFieldEnd();
  }
  if (this.maxMemory !== null && this.maxMemory !== undefined) {
    output.writeFieldBegin('maxMemory', Thrift.Type.I64, 2);
    output.writeI64(this.maxMemory);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TConfigNodeLocation = module.exports.TConfigNodeLocation = function(args) {
  this.configNodeId = null;
  this.internalEndPoint = null;
  this.consensusEndPoint = null;
  if (args) {
    if (args.configNodeId !== undefined && args.configNodeId !== null) {
      this.configNodeId = args.configNodeId;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field configNodeId is unset!');
    }
    if (args.internalEndPoint !== undefined && args.internalEndPoint !== null) {
      this.internalEndPoint = new ttypes.TEndPoint(args.internalEndPoint);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field internalEndPoint is unset!');
    }
    if (args.consensusEndPoint !== undefined && args.consensusEndPoint !== null) {
      this.consensusEndPoint = new ttypes.TEndPoint(args.consensusEndPoint);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field consensusEndPoint is unset!');
    }
  }
};
TConfigNodeLocation.prototype = {};
TConfigNodeLocation.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.configNodeId = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.internalEndPoint = new ttypes.TEndPoint();
        this.internalEndPoint.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.consensusEndPoint = new ttypes.TEndPoint();
        this.consensusEndPoint.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TConfigNodeLocation.prototype.write = function(output) {
  output.writeStructBegin('TConfigNodeLocation');
  if (this.configNodeId !== null && this.configNodeId !== undefined) {
    output.writeFieldBegin('configNodeId', Thrift.Type.I32, 1);
    output.writeI32(this.configNodeId);
    output.writeFieldEnd();
  }
  if (this.internalEndPoint !== null && this.internalEndPoint !== undefined) {
    output.writeFieldBegin('internalEndPoint', Thrift.Type.STRUCT, 2);
    this.internalEndPoint.write(output);
    output.writeFieldEnd();
  }
  if (this.consensusEndPoint !== null && this.consensusEndPoint !== undefined) {
    output.writeFieldBegin('consensusEndPoint', Thrift.Type.STRUCT, 3);
    this.consensusEndPoint.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TDataNodeLocation = module.exports.TDataNodeLocation = function(args) {
  this.dataNodeId = null;
  this.clientRpcEndPoint = null;
  this.internalEndPoint = null;
  this.mPPDataExchangeEndPoint = null;
  this.dataRegionConsensusEndPoint = null;
  this.schemaRegionConsensusEndPoint = null;
  if (args) {
    if (args.dataNodeId !== undefined && args.dataNodeId !== null) {
      this.dataNodeId = args.dataNodeId;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field dataNodeId is unset!');
    }
    if (args.clientRpcEndPoint !== undefined && args.clientRpcEndPoint !== null) {
      this.clientRpcEndPoint = new ttypes.TEndPoint(args.clientRpcEndPoint);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field clientRpcEndPoint is unset!');
    }
    if (args.internalEndPoint !== undefined && args.internalEndPoint !== null) {
      this.internalEndPoint = new ttypes.TEndPoint(args.internalEndPoint);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field internalEndPoint is unset!');
    }
    if (args.mPPDataExchangeEndPoint !== undefined && args.mPPDataExchangeEndPoint !== null) {
      this.mPPDataExchangeEndPoint = new ttypes.TEndPoint(args.mPPDataExchangeEndPoint);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field mPPDataExchangeEndPoint is unset!');
    }
    if (args.dataRegionConsensusEndPoint !== undefined && args.dataRegionConsensusEndPoint !== null) {
      this.dataRegionConsensusEndPoint = new ttypes.TEndPoint(args.dataRegionConsensusEndPoint);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field dataRegionConsensusEndPoint is unset!');
    }
    if (args.schemaRegionConsensusEndPoint !== undefined && args.schemaRegionConsensusEndPoint !== null) {
      this.schemaRegionConsensusEndPoint = new ttypes.TEndPoint(args.schemaRegionConsensusEndPoint);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field schemaRegionConsensusEndPoint is unset!');
    }
  }
};
TDataNodeLocation.prototype = {};
TDataNodeLocation.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.dataNodeId = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.clientRpcEndPoint = new ttypes.TEndPoint();
        this.clientRpcEndPoint.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.internalEndPoint = new ttypes.TEndPoint();
        this.internalEndPoint.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.mPPDataExchangeEndPoint = new ttypes.TEndPoint();
        this.mPPDataExchangeEndPoint.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRUCT) {
        this.dataRegionConsensusEndPoint = new ttypes.TEndPoint();
        this.dataRegionConsensusEndPoint.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRUCT) {
        this.schemaRegionConsensusEndPoint = new ttypes.TEndPoint();
        this.schemaRegionConsensusEndPoint.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TDataNodeLocation.prototype.write = function(output) {
  output.writeStructBegin('TDataNodeLocation');
  if (this.dataNodeId !== null && this.dataNodeId !== undefined) {
    output.writeFieldBegin('dataNodeId', Thrift.Type.I32, 1);
    output.writeI32(this.dataNodeId);
    output.writeFieldEnd();
  }
  if (this.clientRpcEndPoint !== null && this.clientRpcEndPoint !== undefined) {
    output.writeFieldBegin('clientRpcEndPoint', Thrift.Type.STRUCT, 2);
    this.clientRpcEndPoint.write(output);
    output.writeFieldEnd();
  }
  if (this.internalEndPoint !== null && this.internalEndPoint !== undefined) {
    output.writeFieldBegin('internalEndPoint', Thrift.Type.STRUCT, 3);
    this.internalEndPoint.write(output);
    output.writeFieldEnd();
  }
  if (this.mPPDataExchangeEndPoint !== null && this.mPPDataExchangeEndPoint !== undefined) {
    output.writeFieldBegin('mPPDataExchangeEndPoint', Thrift.Type.STRUCT, 4);
    this.mPPDataExchangeEndPoint.write(output);
    output.writeFieldEnd();
  }
  if (this.dataRegionConsensusEndPoint !== null && this.dataRegionConsensusEndPoint !== undefined) {
    output.writeFieldBegin('dataRegionConsensusEndPoint', Thrift.Type.STRUCT, 5);
    this.dataRegionConsensusEndPoint.write(output);
    output.writeFieldEnd();
  }
  if (this.schemaRegionConsensusEndPoint !== null && this.schemaRegionConsensusEndPoint !== undefined) {
    output.writeFieldBegin('schemaRegionConsensusEndPoint', Thrift.Type.STRUCT, 6);
    this.schemaRegionConsensusEndPoint.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TAINodeLocation = module.exports.TAINodeLocation = function(args) {
  this.aiNodeId = null;
  this.internalEndPoint = null;
  if (args) {
    if (args.aiNodeId !== undefined && args.aiNodeId !== null) {
      this.aiNodeId = args.aiNodeId;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field aiNodeId is unset!');
    }
    if (args.internalEndPoint !== undefined && args.internalEndPoint !== null) {
      this.internalEndPoint = new ttypes.TEndPoint(args.internalEndPoint);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field internalEndPoint is unset!');
    }
  }
};
TAINodeLocation.prototype = {};
TAINodeLocation.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.aiNodeId = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.internalEndPoint = new ttypes.TEndPoint();
        this.internalEndPoint.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TAINodeLocation.prototype.write = function(output) {
  output.writeStructBegin('TAINodeLocation');
  if (this.aiNodeId !== null && this.aiNodeId !== undefined) {
    output.writeFieldBegin('aiNodeId', Thrift.Type.I32, 1);
    output.writeI32(this.aiNodeId);
    output.writeFieldEnd();
  }
  if (this.internalEndPoint !== null && this.internalEndPoint !== undefined) {
    output.writeFieldBegin('internalEndPoint', Thrift.Type.STRUCT, 2);
    this.internalEndPoint.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TDataNodeConfiguration = module.exports.TDataNodeConfiguration = function(args) {
  this.location = null;
  this.resource = null;
  if (args) {
    if (args.location !== undefined && args.location !== null) {
      this.location = new ttypes.TDataNodeLocation(args.location);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field location is unset!');
    }
    if (args.resource !== undefined && args.resource !== null) {
      this.resource = new ttypes.TNodeResource(args.resource);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field resource is unset!');
    }
  }
};
TDataNodeConfiguration.prototype = {};
TDataNodeConfiguration.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.location = new ttypes.TDataNodeLocation();
        this.location.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.resource = new ttypes.TNodeResource();
        this.resource.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TDataNodeConfiguration.prototype.write = function(output) {
  output.writeStructBegin('TDataNodeConfiguration');
  if (this.location !== null && this.location !== undefined) {
    output.writeFieldBegin('location', Thrift.Type.STRUCT, 1);
    this.location.write(output);
    output.writeFieldEnd();
  }
  if (this.resource !== null && this.resource !== undefined) {
    output.writeFieldBegin('resource', Thrift.Type.STRUCT, 2);
    this.resource.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TAINodeConfiguration = module.exports.TAINodeConfiguration = function(args) {
  this.location = null;
  this.resource = null;
  if (args) {
    if (args.location !== undefined && args.location !== null) {
      this.location = new ttypes.TAINodeLocation(args.location);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field location is unset!');
    }
    if (args.resource !== undefined && args.resource !== null) {
      this.resource = new ttypes.TNodeResource(args.resource);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field resource is unset!');
    }
  }
};
TAINodeConfiguration.prototype = {};
TAINodeConfiguration.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.location = new ttypes.TAINodeLocation();
        this.location.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.resource = new ttypes.TNodeResource();
        this.resource.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TAINodeConfiguration.prototype.write = function(output) {
  output.writeStructBegin('TAINodeConfiguration');
  if (this.location !== null && this.location !== undefined) {
    output.writeFieldBegin('location', Thrift.Type.STRUCT, 1);
    this.location.write(output);
    output.writeFieldEnd();
  }
  if (this.resource !== null && this.resource !== undefined) {
    output.writeFieldBegin('resource', Thrift.Type.STRUCT, 2);
    this.resource.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TFlushReq = module.exports.TFlushReq = function(args) {
  this.isSeq = null;
  this.storageGroups = null;
  if (args) {
    if (args.isSeq !== undefined && args.isSeq !== null) {
      this.isSeq = args.isSeq;
    }
    if (args.storageGroups !== undefined && args.storageGroups !== null) {
      this.storageGroups = Thrift.copyList(args.storageGroups, [null]);
    }
  }
};
TFlushReq.prototype = {};
TFlushReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.isSeq = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.storageGroups = [];
        var _rtmp311 = input.readListBegin();
        var _size10 = _rtmp311.size || 0;
        for (var _i12 = 0; _i12 < _size10; ++_i12) {
          var elem13 = null;
          elem13 = input.readString();
          this.storageGroups.push(elem13);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TFlushReq.prototype.write = function(output) {
  output.writeStructBegin('TFlushReq');
  if (this.isSeq !== null && this.isSeq !== undefined) {
    output.writeFieldBegin('isSeq', Thrift.Type.STRING, 1);
    output.writeString(this.isSeq);
    output.writeFieldEnd();
  }
  if (this.storageGroups !== null && this.storageGroups !== undefined) {
    output.writeFieldBegin('storageGroups', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRING, this.storageGroups.length);
    for (var iter14 in this.storageGroups) {
      if (this.storageGroups.hasOwnProperty(iter14)) {
        iter14 = this.storageGroups[iter14];
        output.writeString(iter14);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSettleReq = module.exports.TSettleReq = function(args) {
  this.paths = null;
  if (args) {
    if (args.paths !== undefined && args.paths !== null) {
      this.paths = Thrift.copyList(args.paths, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field paths is unset!');
    }
  }
};
TSettleReq.prototype = {};
TSettleReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.paths = [];
        var _rtmp316 = input.readListBegin();
        var _size15 = _rtmp316.size || 0;
        for (var _i17 = 0; _i17 < _size15; ++_i17) {
          var elem18 = null;
          elem18 = input.readString();
          this.paths.push(elem18);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSettleReq.prototype.write = function(output) {
  output.writeStructBegin('TSettleReq');
  if (this.paths !== null && this.paths !== undefined) {
    output.writeFieldBegin('paths', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.paths.length);
    for (var iter19 in this.paths) {
      if (this.paths.hasOwnProperty(iter19)) {
        iter19 = this.paths[iter19];
        output.writeString(iter19);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSchemaNode = module.exports.TSchemaNode = function(args) {
  this.nodeName = null;
  this.nodeType = null;
  if (args) {
    if (args.nodeName !== undefined && args.nodeName !== null) {
      this.nodeName = args.nodeName;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field nodeName is unset!');
    }
    if (args.nodeType !== undefined && args.nodeType !== null) {
      this.nodeType = args.nodeType;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field nodeType is unset!');
    }
  }
};
TSchemaNode.prototype = {};
TSchemaNode.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.nodeName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BYTE) {
        this.nodeType = input.readByte();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSchemaNode.prototype.write = function(output) {
  output.writeStructBegin('TSchemaNode');
  if (this.nodeName !== null && this.nodeName !== undefined) {
    output.writeFieldBegin('nodeName', Thrift.Type.STRING, 1);
    output.writeString(this.nodeName);
    output.writeFieldEnd();
  }
  if (this.nodeType !== null && this.nodeType !== undefined) {
    output.writeFieldBegin('nodeType', Thrift.Type.BYTE, 2);
    output.writeByte(this.nodeType);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSetConfigurationReq = module.exports.TSetConfigurationReq = function(args) {
  this.configs = null;
  this.nodeId = null;
  if (args) {
    if (args.configs !== undefined && args.configs !== null) {
      this.configs = Thrift.copyMap(args.configs, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field configs is unset!');
    }
    if (args.nodeId !== undefined && args.nodeId !== null) {
      this.nodeId = args.nodeId;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field nodeId is unset!');
    }
  }
};
TSetConfigurationReq.prototype = {};
TSetConfigurationReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        this.configs = {};
        var _rtmp321 = input.readMapBegin();
        var _size20 = _rtmp321.size || 0;
        for (var _i22 = 0; _i22 < _size20; ++_i22) {
          var key23 = null;
          var val24 = null;
          key23 = input.readString();
          val24 = input.readString();
          this.configs[key23] = val24;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.nodeId = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSetConfigurationReq.prototype.write = function(output) {
  output.writeStructBegin('TSetConfigurationReq');
  if (this.configs !== null && this.configs !== undefined) {
    output.writeFieldBegin('configs', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.configs));
    for (var kiter25 in this.configs) {
      if (this.configs.hasOwnProperty(kiter25)) {
        var viter26 = this.configs[kiter25];
        output.writeString(kiter25);
        output.writeString(viter26);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.nodeId !== null && this.nodeId !== undefined) {
    output.writeFieldBegin('nodeId', Thrift.Type.I32, 2);
    output.writeI32(this.nodeId);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSetTTLReq = module.exports.TSetTTLReq = function(args) {
  this.pathPattern = null;
  this.TTL = null;
  this.isDataBase = null;
  if (args) {
    if (args.pathPattern !== undefined && args.pathPattern !== null) {
      this.pathPattern = Thrift.copyList(args.pathPattern, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field pathPattern is unset!');
    }
    if (args.TTL !== undefined && args.TTL !== null) {
      this.TTL = args.TTL;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field TTL is unset!');
    }
    if (args.isDataBase !== undefined && args.isDataBase !== null) {
      this.isDataBase = args.isDataBase;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field isDataBase is unset!');
    }
  }
};
TSetTTLReq.prototype = {};
TSetTTLReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.pathPattern = [];
        var _rtmp328 = input.readListBegin();
        var _size27 = _rtmp328.size || 0;
        for (var _i29 = 0; _i29 < _size27; ++_i29) {
          var elem30 = null;
          elem30 = input.readString();
          this.pathPattern.push(elem30);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.TTL = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.isDataBase = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSetTTLReq.prototype.write = function(output) {
  output.writeStructBegin('TSetTTLReq');
  if (this.pathPattern !== null && this.pathPattern !== undefined) {
    output.writeFieldBegin('pathPattern', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.pathPattern.length);
    for (var iter31 in this.pathPattern) {
      if (this.pathPattern.hasOwnProperty(iter31)) {
        iter31 = this.pathPattern[iter31];
        output.writeString(iter31);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.TTL !== null && this.TTL !== undefined) {
    output.writeFieldBegin('TTL', Thrift.Type.I64, 2);
    output.writeI64(this.TTL);
    output.writeFieldEnd();
  }
  if (this.isDataBase !== null && this.isDataBase !== undefined) {
    output.writeFieldBegin('isDataBase', Thrift.Type.BOOL, 3);
    output.writeBool(this.isDataBase);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TShowTTLReq = module.exports.TShowTTLReq = function(args) {
  this.pathPattern = null;
  if (args) {
    if (args.pathPattern !== undefined && args.pathPattern !== null) {
      this.pathPattern = Thrift.copyList(args.pathPattern, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field pathPattern is unset!');
    }
  }
};
TShowTTLReq.prototype = {};
TShowTTLReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.pathPattern = [];
        var _rtmp333 = input.readListBegin();
        var _size32 = _rtmp333.size || 0;
        for (var _i34 = 0; _i34 < _size32; ++_i34) {
          var elem35 = null;
          elem35 = input.readString();
          this.pathPattern.push(elem35);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TShowTTLReq.prototype.write = function(output) {
  output.writeStructBegin('TShowTTLReq');
  if (this.pathPattern !== null && this.pathPattern !== undefined) {
    output.writeFieldBegin('pathPattern', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.pathPattern.length);
    for (var iter36 in this.pathPattern) {
      if (this.pathPattern.hasOwnProperty(iter36)) {
        iter36 = this.pathPattern[iter36];
        output.writeString(iter36);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TFile = module.exports.TFile = function(args) {
  this.fileName = null;
  this.file = null;
  if (args) {
    if (args.fileName !== undefined && args.fileName !== null) {
      this.fileName = args.fileName;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field fileName is unset!');
    }
    if (args.file !== undefined && args.file !== null) {
      this.file = args.file;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field file is unset!');
    }
  }
};
TFile.prototype = {};
TFile.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.fileName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.file = input.readBinary();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TFile.prototype.write = function(output) {
  output.writeStructBegin('TFile');
  if (this.fileName !== null && this.fileName !== undefined) {
    output.writeFieldBegin('fileName', Thrift.Type.STRING, 1);
    output.writeString(this.fileName);
    output.writeFieldEnd();
  }
  if (this.file !== null && this.file !== undefined) {
    output.writeFieldBegin('file', Thrift.Type.STRING, 2);
    output.writeBinary(this.file);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TFilesResp = module.exports.TFilesResp = function(args) {
  this.status = null;
  this.files = null;
  if (args) {
    if (args.status !== undefined && args.status !== null) {
      this.status = new ttypes.TSStatus(args.status);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field status is unset!');
    }
    if (args.files !== undefined && args.files !== null) {
      this.files = Thrift.copyList(args.files, [ttypes.TFile]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field files is unset!');
    }
  }
};
TFilesResp.prototype = {};
TFilesResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.status = new ttypes.TSStatus();
        this.status.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.files = [];
        var _rtmp338 = input.readListBegin();
        var _size37 = _rtmp338.size || 0;
        for (var _i39 = 0; _i39 < _size37; ++_i39) {
          var elem40 = null;
          elem40 = new ttypes.TFile();
          elem40.read(input);
          this.files.push(elem40);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TFilesResp.prototype.write = function(output) {
  output.writeStructBegin('TFilesResp');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.STRUCT, 1);
    this.status.write(output);
    output.writeFieldEnd();
  }
  if (this.files !== null && this.files !== undefined) {
    output.writeFieldBegin('files', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.files.length);
    for (var iter41 in this.files) {
      if (this.files.hasOwnProperty(iter41)) {
        iter41 = this.files[iter41];
        iter41.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSpaceQuota = module.exports.TSpaceQuota = function(args) {
  this.diskSize = null;
  this.deviceNum = null;
  this.timeserieNum = null;
  if (args) {
    if (args.diskSize !== undefined && args.diskSize !== null) {
      this.diskSize = args.diskSize;
    }
    if (args.deviceNum !== undefined && args.deviceNum !== null) {
      this.deviceNum = args.deviceNum;
    }
    if (args.timeserieNum !== undefined && args.timeserieNum !== null) {
      this.timeserieNum = args.timeserieNum;
    }
  }
};
TSpaceQuota.prototype = {};
TSpaceQuota.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.diskSize = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.deviceNum = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I64) {
        this.timeserieNum = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSpaceQuota.prototype.write = function(output) {
  output.writeStructBegin('TSpaceQuota');
  if (this.diskSize !== null && this.diskSize !== undefined) {
    output.writeFieldBegin('diskSize', Thrift.Type.I64, 1);
    output.writeI64(this.diskSize);
    output.writeFieldEnd();
  }
  if (this.deviceNum !== null && this.deviceNum !== undefined) {
    output.writeFieldBegin('deviceNum', Thrift.Type.I64, 2);
    output.writeI64(this.deviceNum);
    output.writeFieldEnd();
  }
  if (this.timeserieNum !== null && this.timeserieNum !== undefined) {
    output.writeFieldBegin('timeserieNum', Thrift.Type.I64, 3);
    output.writeI64(this.timeserieNum);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TTimedQuota = module.exports.TTimedQuota = function(args) {
  this.timeUnit = null;
  this.softLimit = null;
  if (args) {
    if (args.timeUnit !== undefined && args.timeUnit !== null) {
      this.timeUnit = args.timeUnit;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field timeUnit is unset!');
    }
    if (args.softLimit !== undefined && args.softLimit !== null) {
      this.softLimit = args.softLimit;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field softLimit is unset!');
    }
  }
};
TTimedQuota.prototype = {};
TTimedQuota.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.timeUnit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.softLimit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TTimedQuota.prototype.write = function(output) {
  output.writeStructBegin('TTimedQuota');
  if (this.timeUnit !== null && this.timeUnit !== undefined) {
    output.writeFieldBegin('timeUnit', Thrift.Type.I64, 1);
    output.writeI64(this.timeUnit);
    output.writeFieldEnd();
  }
  if (this.softLimit !== null && this.softLimit !== undefined) {
    output.writeFieldBegin('softLimit', Thrift.Type.I64, 2);
    output.writeI64(this.softLimit);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TThrottleQuota = module.exports.TThrottleQuota = function(args) {
  this.throttleLimit = null;
  this.memLimit = null;
  this.cpuLimit = null;
  if (args) {
    if (args.throttleLimit !== undefined && args.throttleLimit !== null) {
      this.throttleLimit = Thrift.copyMap(args.throttleLimit, [ttypes.TTimedQuota]);
    }
    if (args.memLimit !== undefined && args.memLimit !== null) {
      this.memLimit = args.memLimit;
    }
    if (args.cpuLimit !== undefined && args.cpuLimit !== null) {
      this.cpuLimit = args.cpuLimit;
    }
  }
};
TThrottleQuota.prototype = {};
TThrottleQuota.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.MAP) {
        this.throttleLimit = {};
        var _rtmp343 = input.readMapBegin();
        var _size42 = _rtmp343.size || 0;
        for (var _i44 = 0; _i44 < _size42; ++_i44) {
          var key45 = null;
          var val46 = null;
          key45 = input.readI32();
          val46 = new ttypes.TTimedQuota();
          val46.read(input);
          this.throttleLimit[key45] = val46;
        }
        input.readMapEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.memLimit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.cpuLimit = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TThrottleQuota.prototype.write = function(output) {
  output.writeStructBegin('TThrottleQuota');
  if (this.throttleLimit !== null && this.throttleLimit !== undefined) {
    output.writeFieldBegin('throttleLimit', Thrift.Type.MAP, 1);
    output.writeMapBegin(Thrift.Type.I32, Thrift.Type.STRUCT, Thrift.objectLength(this.throttleLimit));
    for (var kiter47 in this.throttleLimit) {
      if (this.throttleLimit.hasOwnProperty(kiter47)) {
        var viter48 = this.throttleLimit[kiter47];
        output.writeI32(kiter47);
        viter48.write(output);
      }
    }
    output.writeMapEnd();
    output.writeFieldEnd();
  }
  if (this.memLimit !== null && this.memLimit !== undefined) {
    output.writeFieldBegin('memLimit', Thrift.Type.I64, 2);
    output.writeI64(this.memLimit);
    output.writeFieldEnd();
  }
  if (this.cpuLimit !== null && this.cpuLimit !== undefined) {
    output.writeFieldBegin('cpuLimit', Thrift.Type.I32, 3);
    output.writeI32(this.cpuLimit);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSetSpaceQuotaReq = module.exports.TSetSpaceQuotaReq = function(args) {
  this.database = null;
  this.spaceLimit = null;
  if (args) {
    if (args.database !== undefined && args.database !== null) {
      this.database = Thrift.copyList(args.database, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field database is unset!');
    }
    if (args.spaceLimit !== undefined && args.spaceLimit !== null) {
      this.spaceLimit = new ttypes.TSpaceQuota(args.spaceLimit);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field spaceLimit is unset!');
    }
  }
};
TSetSpaceQuotaReq.prototype = {};
TSetSpaceQuotaReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.database = [];
        var _rtmp350 = input.readListBegin();
        var _size49 = _rtmp350.size || 0;
        for (var _i51 = 0; _i51 < _size49; ++_i51) {
          var elem52 = null;
          elem52 = input.readString();
          this.database.push(elem52);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.spaceLimit = new ttypes.TSpaceQuota();
        this.spaceLimit.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSetSpaceQuotaReq.prototype.write = function(output) {
  output.writeStructBegin('TSetSpaceQuotaReq');
  if (this.database !== null && this.database !== undefined) {
    output.writeFieldBegin('database', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRING, this.database.length);
    for (var iter53 in this.database) {
      if (this.database.hasOwnProperty(iter53)) {
        iter53 = this.database[iter53];
        output.writeString(iter53);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.spaceLimit !== null && this.spaceLimit !== undefined) {
    output.writeFieldBegin('spaceLimit', Thrift.Type.STRUCT, 2);
    this.spaceLimit.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSetThrottleQuotaReq = module.exports.TSetThrottleQuotaReq = function(args) {
  this.userName = null;
  this.throttleQuota = null;
  if (args) {
    if (args.userName !== undefined && args.userName !== null) {
      this.userName = args.userName;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field userName is unset!');
    }
    if (args.throttleQuota !== undefined && args.throttleQuota !== null) {
      this.throttleQuota = new ttypes.TThrottleQuota(args.throttleQuota);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field throttleQuota is unset!');
    }
  }
};
TSetThrottleQuotaReq.prototype = {};
TSetThrottleQuotaReq.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.userName = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.throttleQuota = new ttypes.TThrottleQuota();
        this.throttleQuota.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSetThrottleQuotaReq.prototype.write = function(output) {
  output.writeStructBegin('TSetThrottleQuotaReq');
  if (this.userName !== null && this.userName !== undefined) {
    output.writeFieldBegin('userName', Thrift.Type.STRING, 1);
    output.writeString(this.userName);
    output.writeFieldEnd();
  }
  if (this.throttleQuota !== null && this.throttleQuota !== undefined) {
    output.writeFieldBegin('throttleQuota', Thrift.Type.STRUCT, 2);
    this.throttleQuota.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TLicense = module.exports.TLicense = function(args) {
  this.licenseIssueTimestamp = null;
  this.expireTimestamp = null;
  this.dataNodeNumLimit = null;
  this.cpuCoreNumLimit = null;
  this.deviceNumLimit = null;
  this.sensorNumLimit = null;
  this.disconnectionFromActiveNodeTimeLimit = null;
  this.mlNodeNumLimit = null;
  if (args) {
    if (args.licenseIssueTimestamp !== undefined && args.licenseIssueTimestamp !== null) {
      this.licenseIssueTimestamp = args.licenseIssueTimestamp;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field licenseIssueTimestamp is unset!');
    }
    if (args.expireTimestamp !== undefined && args.expireTimestamp !== null) {
      this.expireTimestamp = args.expireTimestamp;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field expireTimestamp is unset!');
    }
    if (args.dataNodeNumLimit !== undefined && args.dataNodeNumLimit !== null) {
      this.dataNodeNumLimit = args.dataNodeNumLimit;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field dataNodeNumLimit is unset!');
    }
    if (args.cpuCoreNumLimit !== undefined && args.cpuCoreNumLimit !== null) {
      this.cpuCoreNumLimit = args.cpuCoreNumLimit;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field cpuCoreNumLimit is unset!');
    }
    if (args.deviceNumLimit !== undefined && args.deviceNumLimit !== null) {
      this.deviceNumLimit = args.deviceNumLimit;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field deviceNumLimit is unset!');
    }
    if (args.sensorNumLimit !== undefined && args.sensorNumLimit !== null) {
      this.sensorNumLimit = args.sensorNumLimit;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field sensorNumLimit is unset!');
    }
    if (args.disconnectionFromActiveNodeTimeLimit !== undefined && args.disconnectionFromActiveNodeTimeLimit !== null) {
      this.disconnectionFromActiveNodeTimeLimit = args.disconnectionFromActiveNodeTimeLimit;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field disconnectionFromActiveNodeTimeLimit is unset!');
    }
    if (args.mlNodeNumLimit !== undefined && args.mlNodeNumLimit !== null) {
      this.mlNodeNumLimit = args.mlNodeNumLimit;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field mlNodeNumLimit is unset!');
    }
  }
};
TLicense.prototype = {};
TLicense.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.I64) {
        this.licenseIssueTimestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.expireTimestamp = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.I16) {
        this.dataNodeNumLimit = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.I32) {
        this.cpuCoreNumLimit = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.I64) {
        this.deviceNumLimit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.I64) {
        this.sensorNumLimit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.I64) {
        this.disconnectionFromActiveNodeTimeLimit = input.readI64();
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.I16) {
        this.mlNodeNumLimit = input.readI16();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TLicense.prototype.write = function(output) {
  output.writeStructBegin('TLicense');
  if (this.licenseIssueTimestamp !== null && this.licenseIssueTimestamp !== undefined) {
    output.writeFieldBegin('licenseIssueTimestamp', Thrift.Type.I64, 1);
    output.writeI64(this.licenseIssueTimestamp);
    output.writeFieldEnd();
  }
  if (this.expireTimestamp !== null && this.expireTimestamp !== undefined) {
    output.writeFieldBegin('expireTimestamp', Thrift.Type.I64, 2);
    output.writeI64(this.expireTimestamp);
    output.writeFieldEnd();
  }
  if (this.dataNodeNumLimit !== null && this.dataNodeNumLimit !== undefined) {
    output.writeFieldBegin('dataNodeNumLimit', Thrift.Type.I16, 4);
    output.writeI16(this.dataNodeNumLimit);
    output.writeFieldEnd();
  }
  if (this.cpuCoreNumLimit !== null && this.cpuCoreNumLimit !== undefined) {
    output.writeFieldBegin('cpuCoreNumLimit', Thrift.Type.I32, 5);
    output.writeI32(this.cpuCoreNumLimit);
    output.writeFieldEnd();
  }
  if (this.deviceNumLimit !== null && this.deviceNumLimit !== undefined) {
    output.writeFieldBegin('deviceNumLimit', Thrift.Type.I64, 6);
    output.writeI64(this.deviceNumLimit);
    output.writeFieldEnd();
  }
  if (this.sensorNumLimit !== null && this.sensorNumLimit !== undefined) {
    output.writeFieldBegin('sensorNumLimit', Thrift.Type.I64, 7);
    output.writeI64(this.sensorNumLimit);
    output.writeFieldEnd();
  }
  if (this.disconnectionFromActiveNodeTimeLimit !== null && this.disconnectionFromActiveNodeTimeLimit !== undefined) {
    output.writeFieldBegin('disconnectionFromActiveNodeTimeLimit', Thrift.Type.I64, 8);
    output.writeI64(this.disconnectionFromActiveNodeTimeLimit);
    output.writeFieldEnd();
  }
  if (this.mlNodeNumLimit !== null && this.mlNodeNumLimit !== undefined) {
    output.writeFieldBegin('mlNodeNumLimit', Thrift.Type.I16, 9);
    output.writeI16(this.mlNodeNumLimit);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TLoadSample = module.exports.TLoadSample = function(args) {
  this.cpuUsageRate = null;
  this.memoryUsageRate = null;
  this.diskUsageRate = null;
  this.freeDiskSpace = null;
  if (args) {
    if (args.cpuUsageRate !== undefined && args.cpuUsageRate !== null) {
      this.cpuUsageRate = args.cpuUsageRate;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field cpuUsageRate is unset!');
    }
    if (args.memoryUsageRate !== undefined && args.memoryUsageRate !== null) {
      this.memoryUsageRate = args.memoryUsageRate;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field memoryUsageRate is unset!');
    }
    if (args.diskUsageRate !== undefined && args.diskUsageRate !== null) {
      this.diskUsageRate = args.diskUsageRate;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field diskUsageRate is unset!');
    }
    if (args.freeDiskSpace !== undefined && args.freeDiskSpace !== null) {
      this.freeDiskSpace = args.freeDiskSpace;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field freeDiskSpace is unset!');
    }
  }
};
TLoadSample.prototype = {};
TLoadSample.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.DOUBLE) {
        this.cpuUsageRate = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.DOUBLE) {
        this.memoryUsageRate = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.DOUBLE) {
        this.diskUsageRate = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.DOUBLE) {
        this.freeDiskSpace = input.readDouble();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TLoadSample.prototype.write = function(output) {
  output.writeStructBegin('TLoadSample');
  if (this.cpuUsageRate !== null && this.cpuUsageRate !== undefined) {
    output.writeFieldBegin('cpuUsageRate', Thrift.Type.DOUBLE, 1);
    output.writeDouble(this.cpuUsageRate);
    output.writeFieldEnd();
  }
  if (this.memoryUsageRate !== null && this.memoryUsageRate !== undefined) {
    output.writeFieldBegin('memoryUsageRate', Thrift.Type.DOUBLE, 2);
    output.writeDouble(this.memoryUsageRate);
    output.writeFieldEnd();
  }
  if (this.diskUsageRate !== null && this.diskUsageRate !== undefined) {
    output.writeFieldBegin('diskUsageRate', Thrift.Type.DOUBLE, 3);
    output.writeDouble(this.diskUsageRate);
    output.writeFieldEnd();
  }
  if (this.freeDiskSpace !== null && this.freeDiskSpace !== undefined) {
    output.writeFieldBegin('freeDiskSpace', Thrift.Type.DOUBLE, 4);
    output.writeDouble(this.freeDiskSpace);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TServiceProvider = module.exports.TServiceProvider = function(args) {
  this.endPoint = null;
  this.serviceType = null;
  if (args) {
    if (args.endPoint !== undefined && args.endPoint !== null) {
      this.endPoint = new ttypes.TEndPoint(args.endPoint);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field endPoint is unset!');
    }
    if (args.serviceType !== undefined && args.serviceType !== null) {
      this.serviceType = args.serviceType;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field serviceType is unset!');
    }
  }
};
TServiceProvider.prototype = {};
TServiceProvider.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.endPoint = new ttypes.TEndPoint();
        this.endPoint.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.serviceType = input.readI32();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TServiceProvider.prototype.write = function(output) {
  output.writeStructBegin('TServiceProvider');
  if (this.endPoint !== null && this.endPoint !== undefined) {
    output.writeFieldBegin('endPoint', Thrift.Type.STRUCT, 1);
    this.endPoint.write(output);
    output.writeFieldEnd();
  }
  if (this.serviceType !== null && this.serviceType !== undefined) {
    output.writeFieldBegin('serviceType', Thrift.Type.I32, 2);
    output.writeI32(this.serviceType);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TSender = module.exports.TSender = function(args) {
  this.dataNodeLocation = null;
  this.configNodeLocation = null;
  if (args) {
    if (args.dataNodeLocation !== undefined && args.dataNodeLocation !== null) {
      this.dataNodeLocation = new ttypes.TDataNodeLocation(args.dataNodeLocation);
    }
    if (args.configNodeLocation !== undefined && args.configNodeLocation !== null) {
      this.configNodeLocation = new ttypes.TConfigNodeLocation(args.configNodeLocation);
    }
  }
};
TSender.prototype = {};
TSender.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.dataNodeLocation = new ttypes.TDataNodeLocation();
        this.dataNodeLocation.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.configNodeLocation = new ttypes.TConfigNodeLocation();
        this.configNodeLocation.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TSender.prototype.write = function(output) {
  output.writeStructBegin('TSender');
  if (this.dataNodeLocation !== null && this.dataNodeLocation !== undefined) {
    output.writeFieldBegin('dataNodeLocation', Thrift.Type.STRUCT, 1);
    this.dataNodeLocation.write(output);
    output.writeFieldEnd();
  }
  if (this.configNodeLocation !== null && this.configNodeLocation !== undefined) {
    output.writeFieldBegin('configNodeLocation', Thrift.Type.STRUCT, 2);
    this.configNodeLocation.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TTestConnectionResult = module.exports.TTestConnectionResult = function(args) {
  this.serviceProvider = null;
  this.sender = null;
  this.success = null;
  this.reason = null;
  if (args) {
    if (args.serviceProvider !== undefined && args.serviceProvider !== null) {
      this.serviceProvider = new ttypes.TServiceProvider(args.serviceProvider);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field serviceProvider is unset!');
    }
    if (args.sender !== undefined && args.sender !== null) {
      this.sender = new ttypes.TSender(args.sender);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field sender is unset!');
    }
    if (args.success !== undefined && args.success !== null) {
      this.success = args.success;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field success is unset!');
    }
    if (args.reason !== undefined && args.reason !== null) {
      this.reason = args.reason;
    }
  }
};
TTestConnectionResult.prototype = {};
TTestConnectionResult.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.serviceProvider = new ttypes.TServiceProvider();
        this.serviceProvider.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.sender = new ttypes.TSender();
        this.sender.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.BOOL) {
        this.success = input.readBool();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.reason = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TTestConnectionResult.prototype.write = function(output) {
  output.writeStructBegin('TTestConnectionResult');
  if (this.serviceProvider !== null && this.serviceProvider !== undefined) {
    output.writeFieldBegin('serviceProvider', Thrift.Type.STRUCT, 1);
    this.serviceProvider.write(output);
    output.writeFieldEnd();
  }
  if (this.sender !== null && this.sender !== undefined) {
    output.writeFieldBegin('sender', Thrift.Type.STRUCT, 2);
    this.sender.write(output);
    output.writeFieldEnd();
  }
  if (this.success !== null && this.success !== undefined) {
    output.writeFieldBegin('success', Thrift.Type.BOOL, 3);
    output.writeBool(this.success);
    output.writeFieldEnd();
  }
  if (this.reason !== null && this.reason !== undefined) {
    output.writeFieldBegin('reason', Thrift.Type.STRING, 4);
    output.writeString(this.reason);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TTestConnectionResp = module.exports.TTestConnectionResp = function(args) {
  this.status = null;
  this.resultList = null;
  if (args) {
    if (args.status !== undefined && args.status !== null) {
      this.status = new ttypes.TSStatus(args.status);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field status is unset!');
    }
    if (args.resultList !== undefined && args.resultList !== null) {
      this.resultList = Thrift.copyList(args.resultList, [ttypes.TTestConnectionResult]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field resultList is unset!');
    }
  }
};
TTestConnectionResp.prototype = {};
TTestConnectionResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.status = new ttypes.TSStatus();
        this.status.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.resultList = [];
        var _rtmp355 = input.readListBegin();
        var _size54 = _rtmp355.size || 0;
        for (var _i56 = 0; _i56 < _size54; ++_i56) {
          var elem57 = null;
          elem57 = new ttypes.TTestConnectionResult();
          elem57.read(input);
          this.resultList.push(elem57);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TTestConnectionResp.prototype.write = function(output) {
  output.writeStructBegin('TTestConnectionResp');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.STRUCT, 1);
    this.status.write(output);
    output.writeFieldEnd();
  }
  if (this.resultList !== null && this.resultList !== undefined) {
    output.writeFieldBegin('resultList', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.resultList.length);
    for (var iter58 in this.resultList) {
      if (this.resultList.hasOwnProperty(iter58)) {
        iter58 = this.resultList[iter58];
        iter58.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TNodeLocations = module.exports.TNodeLocations = function(args) {
  this.configNodeLocations = null;
  this.dataNodeLocations = null;
  if (args) {
    if (args.configNodeLocations !== undefined && args.configNodeLocations !== null) {
      this.configNodeLocations = Thrift.copyList(args.configNodeLocations, [ttypes.TConfigNodeLocation]);
    }
    if (args.dataNodeLocations !== undefined && args.dataNodeLocations !== null) {
      this.dataNodeLocations = Thrift.copyList(args.dataNodeLocations, [ttypes.TDataNodeLocation]);
    }
  }
};
TNodeLocations.prototype = {};
TNodeLocations.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        this.configNodeLocations = [];
        var _rtmp360 = input.readListBegin();
        var _size59 = _rtmp360.size || 0;
        for (var _i61 = 0; _i61 < _size59; ++_i61) {
          var elem62 = null;
          elem62 = new ttypes.TConfigNodeLocation();
          elem62.read(input);
          this.configNodeLocations.push(elem62);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        this.dataNodeLocations = [];
        var _rtmp364 = input.readListBegin();
        var _size63 = _rtmp364.size || 0;
        for (var _i65 = 0; _i65 < _size63; ++_i65) {
          var elem66 = null;
          elem66 = new ttypes.TDataNodeLocation();
          elem66.read(input);
          this.dataNodeLocations.push(elem66);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TNodeLocations.prototype.write = function(output) {
  output.writeStructBegin('TNodeLocations');
  if (this.configNodeLocations !== null && this.configNodeLocations !== undefined) {
    output.writeFieldBegin('configNodeLocations', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.configNodeLocations.length);
    for (var iter67 in this.configNodeLocations) {
      if (this.configNodeLocations.hasOwnProperty(iter67)) {
        iter67 = this.configNodeLocations[iter67];
        iter67.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.dataNodeLocations !== null && this.dataNodeLocations !== undefined) {
    output.writeFieldBegin('dataNodeLocations', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.dataNodeLocations.length);
    for (var iter68 in this.dataNodeLocations) {
      if (this.dataNodeLocations.hasOwnProperty(iter68)) {
        iter68 = this.dataNodeLocations[iter68];
        iter68.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TShowConfigurationTemplateResp = module.exports.TShowConfigurationTemplateResp = function(args) {
  this.status = null;
  this.content = null;
  if (args) {
    if (args.status !== undefined && args.status !== null) {
      this.status = new ttypes.TSStatus(args.status);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field status is unset!');
    }
    if (args.content !== undefined && args.content !== null) {
      this.content = args.content;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field content is unset!');
    }
  }
};
TShowConfigurationTemplateResp.prototype = {};
TShowConfigurationTemplateResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.status = new ttypes.TSStatus();
        this.status.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.content = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TShowConfigurationTemplateResp.prototype.write = function(output) {
  output.writeStructBegin('TShowConfigurationTemplateResp');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.STRUCT, 1);
    this.status.write(output);
    output.writeFieldEnd();
  }
  if (this.content !== null && this.content !== undefined) {
    output.writeFieldBegin('content', Thrift.Type.STRING, 2);
    output.writeString(this.content);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

var TShowConfigurationResp = module.exports.TShowConfigurationResp = function(args) {
  this.status = null;
  this.content = null;
  if (args) {
    if (args.status !== undefined && args.status !== null) {
      this.status = new ttypes.TSStatus(args.status);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field status is unset!');
    }
    if (args.content !== undefined && args.content !== null) {
      this.content = args.content;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field content is unset!');
    }
  }
};
TShowConfigurationResp.prototype = {};
TShowConfigurationResp.prototype.read = function(input) {
  input.readStructBegin();
  while (true) {
    var ret = input.readFieldBegin();
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid) {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.status = new ttypes.TSStatus();
        this.status.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.content = input.readString();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

TShowConfigurationResp.prototype.write = function(output) {
  output.writeStructBegin('TShowConfigurationResp');
  if (this.status !== null && this.status !== undefined) {
    output.writeFieldBegin('status', Thrift.Type.STRUCT, 1);
    this.status.write(output);
    output.writeFieldEnd();
  }
  if (this.content !== null && this.content !== undefined) {
    output.writeFieldBegin('content', Thrift.Type.STRING, 2);
    output.writeString(this.content);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};